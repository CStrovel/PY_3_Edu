# Author: Charles Strovel
# Description: This program demonstrates error handling in python

# When a program is abnormally terminated, an exception is raised
# by the interpreter.  The programmer can catch this exception and
# handle it to prevent the program from crashing.
def errorHandlingBasics():
    """ This function demonstrates the basic syntax for error handling, try and except """

    # For this function we will generate a divide by zero error
    # Declare variables 
    dividend = 15
    divisor = 0 
    
    # For any statment that may cause an error, it is a good idea to attempt it first in a "try"
    # block, with an "except" block used to remidy errors that occur. Typically only one line 
    # of code should be attempted per try block.
    try: 
        quotient = dividend / divisor 
        
        # A try block excepts the remainder of the code within it if a previous line 
        # has caused an error. 
        print("This line would print only if the division operation is succesful")
 
    # Simply using except catches all errors
    except:
        print("An error has occured!") 


# Statements can be the source of multipule different error types, it would still be nice to 
# handle the different types of errors for trouble shooting purposes, or to tell a user what 
# they have done wrong. 
def multipuleErrorHandling():
    """ Demonstrates how to handle multipule different errors caused within a single try block """
    dividend = 15 # misspelled variable names can be a source of errors.
                  # try comment out this variable to get a different error!   
    divisor = 0 
    myString = "String"

    try:
        quotient = dividend / divisor # try dividing by myString to change error type.
    
    # Tracebacks generated by unhandled exceptions will state the error type. These error
    # types can be used to create custom except blocks that will trigger only if that
    # specific error type has been generated within the previous try block.
    
    except ZeroDivisionError: # divide by zero has been attempted.
        print("Exception handled! You can not divide by zero!")

    except TypeError: # A non numeric type has been used in division.
        print("Exception handled! A string was used in division.")

    except: # A generic except block will catch all errors that do not conform to the first two types
        print("Exception handled! An error has occured!")

# Combining previous examples of type conversion with exeption handling we can finally ensure the user
# Gives us useable, safe data! 
def userInputValidation():
    """ Demonstrates how to use exception handling for input validation """
    
    # we will begin by intializing our value. 
    inVar = "Some string"
    flag = True 

    # Input control loop. We will continue to loop while the user has not given us a valid float 
    while flag:
        flag = False # assume the user is nice, we will check
        inVar = input("Please enter a number: ") # get the users data
        print("") # for nice formating 

        # standard input values come in as strings, casting to the numeric type you want is the 
        # perfect time to check if the user has given you a valid number. 
        try:
            inVar = float(inVar)
        
        except ValueError: # If the conversion to float fails.
            print("\nInput value is not a number!")
            flag = True # reset flag to continue the loop and ask again 

        except: # generic exception handling, incase we missed an error case. 
            print("\nAn error has occured, please try again!")
            flag = True # reset flag to continue the loop and ask again 


# flow control 
def main(): 
    """ Demonstrates three different ways to use error handling """

    # Demonstrates basic error handling syntax
    errorHandlingBasics()

    # Demonstrates handling the potential for multipule errors at once
    multipuleErrorHandling()

    # Demonstrates using error handling to check user input
    userInputValidation()


# call main
main()